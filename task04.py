# Реализовать решение СЛАУ двумя итерационными методами:
# методом простой итерации
# + методом Зейделя или методом релаксации.
# Сравнить количество итераций.
# Находить решения с разной точностью (т.е. варьировать ε, до достижения которого проводятся итерации).
# Может быть между ε и количеством итераций k есть зависимость?
#
# Примечание: поскольку релаксационные методы используют
# более “свежую” информацию о сделанных преобразованиях,
# то обычно они сходятся быстрее метода простой итерации.
#
# Протестировать работу методов на плохо обусловленных матрицах —
# например, на примере из методички А.Н.Пакулиной и на матрице Гильберта (см. задание 1).
#
# Если есть возможность — протестировать работу методов на
# симметричных с диагональным преобладанием разреженных матрицах большого порядка(больше 200).
# Реализация метода релаксации с тестированием на больших разреженных матрицах дает дополнительный “плюсик”.

from common_lib import *
from task04_lib import *
from task02_lib import print_diff
from task01_lib import build_hilbert


def test(A: np.array, b: np.array):
    epsilon = 10**(-10)
    X = solve_simple(A, b, epsilon, verbosity=1)
    X_ = np.linalg.solve(A, b)
    print_diff(X, X_)


print_task(4)

# матрица Гильберта
A = build_hilbert(2)
b = np.array([1 for i in range(2)])
print_test("Гильберта 2-го порядка")
test(A, b)

# матрица Гильберта
A = build_hilbert(3)
b = np.array([1 for i in range(3)])
print_test("Гильберта 3-го порядка")
test(A, b)

# матрица Гильберта
A = build_hilbert(10)
b = np.array([1 for i in range(10)])
print_test("Гильберта 10-го порядка")
test(A, b)

# матрица из Пакулиной, стр. 90, вар. 1
A = np.array([[-400.60, 199.80],
              [1198.80, -600.40]])
b = np.array([200, -600])
print_test()
test(A, b)

# матрица из Пакулиной, стр. 94, вар. 1
A = np.array([[3.278164, 1.046583, -1.378574],
              [1.046583, 2.975937, 0.934251],
              [-1.378574, 0.934251, 4.836173]])
b = np.array([-0.527466, 2.526877, 5.165441])
print_test()
test(A, b)
